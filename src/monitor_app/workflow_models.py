"""
Enhanced Django models for SWF workflow tracking.

This module extends the existing models with workflow-specific fields and adds new models
for tracking the complete STF processing pipeline from DAQ generation through agent processing.
"""

import uuid
from django.db import models
from django.utils import timezone


class DAQState(models.TextChoices):
    """
    DAQ system states from the schedule-based simulation.
    These correspond to the detector/accelerator operational states.
    """
    NO_BEAM = "no_beam", "No Beam"
    BEAM = "beam", "Beam"
    RUN = "run", "Run"
    CALIB = "calib", "Calibration"
    TEST = "test", "Test"


class DAQSubstate(models.TextChoices):
    """
    DAQ system substates providing additional context within each main state.
    """
    NOT_READY = "not_ready", "Not Ready"
    READY = "ready", "Ready"
    PHYSICS = "physics", "Physics"
    STANDBY = "standby", "Standby"
    LUMI = "lumi", "Luminosity"
    EIC = "eic", "EIC"
    EPIC = "epic", "ePIC"
    DAQ = "daq", "DAQ"
    CALIB = "calib", "Calibration"


class WorkflowStatus(models.TextChoices):
    """
    Overall workflow status for STF processing through the complete pipeline.
    Complete symmetry across all agent types: daqsim, data, processing, fastmon.
    """
    GENERATED = "generated", "Generated by DAQ"
    
    # DAQSIM Agent statuses
    DAQSIM_RECEIVED = "daqsim_received", "Received by DAQSIM Agent"
    DAQSIM_PROCESSING = "daqsim_processing", "DAQSIM Agent Processing"
    DAQSIM_COMPLETE = "daqsim_complete", "DAQSIM Agent Complete"
    
    # Data Agent statuses
    DATA_RECEIVED = "data_received", "Received by Data Agent"
    DATA_PROCESSING = "data_processing", "Data Agent Processing"
    DATA_COMPLETE = "data_complete", "Data Agent Complete"
    
    # Processing Agent statuses
    PROCESSING_RECEIVED = "processing_received", "Received by Processing Agent"
    PROCESSING_PROCESSING = "processing_processing", "Processing Agent Processing"
    PROCESSING_COMPLETE = "processing_complete", "Processing Agent Complete"
    
    # FastMon Agent statuses
    FASTMON_RECEIVED = "fastmon_received", "Received by FastMon Agent"
    FASTMON_PROCESSING = "fastmon_processing", "FastMon Agent Processing"
    FASTMON_COMPLETE = "fastmon_complete", "FastMon Agent Complete"
    
    # Overall workflow statuses
    WORKFLOW_COMPLETE = "workflow_complete", "Workflow Complete"
    FAILED = "failed", "Failed"


class AgentType(models.TextChoices):
    """
    Standardized agent types for the workflow system.
    """
    DAQSIM = "daqsim", "DAQ Simulator"
    DATA = "data", "Data Agent"
    PROCESSING = "processing", "Processing Agent"
    FASTMON = "fastmon", "Fast Monitoring Agent"
    MONITOR = "monitor", "Monitor System"


class STFWorkflow(models.Model):
    """
    Tracks the complete workflow lifecycle of a Super Time Frame from generation to completion.
    
    This model extends the existing StfFile model concept to include workflow-specific fields
    and tracks the STF as it moves through different agents in the pipeline.
    """
    workflow_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # STF identification and metadata
    filename = models.CharField(max_length=255, unique=True)
    file_id = models.UUIDField(null=True, blank=True)  # Link to StfFile if needed
    
    # DAQ state information
    daq_state = models.CharField(max_length=20, choices=DAQState.choices)
    daq_substate = models.CharField(max_length=20, choices=DAQSubstate.choices)
    
    # Time tracking
    generated_time = models.DateTimeField()  # From STF start time
    stf_start_time = models.DateTimeField()  # From STF metadata
    stf_end_time = models.DateTimeField()    # From STF metadata
    
    # Workflow status
    current_status = models.CharField(
        max_length=30,
        choices=WorkflowStatus.choices,
        default=WorkflowStatus.GENERATED
    )
    
    # Agent tracking
    current_agent = models.CharField(max_length=20, choices=AgentType.choices, default=AgentType.DAQSIM)
    
    # Completion tracking
    completed_at = models.DateTimeField(null=True, blank=True)
    failed_at = models.DateTimeField(null=True, blank=True)
    failure_reason = models.TextField(null=True, blank=True)
    
    # Metadata storage
    stf_metadata = models.JSONField(null=True, blank=True)
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'swf_stf_workflows'
        ordering = ['-generated_time']
        indexes = [
            models.Index(fields=['current_status', 'generated_time']),
            models.Index(fields=['daq_state', 'daq_substate']),
            models.Index(fields=['current_agent']),
        ]

    def __str__(self):
        return f"STF Workflow {self.filename} - {self.current_status}"

    def mark_completed(self):
        """Mark the workflow as completed."""
        self.current_status = WorkflowStatus.WORKFLOW_COMPLETE
        self.completed_at = timezone.now()
        self.save()

    def mark_failed(self, reason):
        """Mark the workflow as failed with a reason."""
        self.current_status = WorkflowStatus.FAILED
        self.failed_at = timezone.now()
        self.failure_reason = reason
        self.save()


class AgentWorkflowStage(models.Model):
    """
    Tracks individual agent processing stages within an STF workflow.
    
    This model records when each agent receives, processes, and completes work on an STF,
    providing detailed timing and status information for performance monitoring.
    """
    stage_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Relationships
    workflow = models.ForeignKey(STFWorkflow, on_delete=models.CASCADE, related_name='stages')
    agent_name = models.CharField(max_length=100)  # Instance name of the agent
    agent_type = models.CharField(max_length=20, choices=AgentType.choices)
    
    # Status tracking
    status = models.CharField(
        max_length=30,
        choices=WorkflowStatus.choices,
        default=WorkflowStatus.GENERATED
    )
    
    # Timing
    received_at = models.DateTimeField(null=True, blank=True)
    started_at = models.DateTimeField(null=True, blank=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    failed_at = models.DateTimeField(null=True, blank=True)
    
    # Processing details
    processing_time_seconds = models.FloatField(null=True, blank=True)
    failure_reason = models.TextField(null=True, blank=True)
    
    # Message tracking
    input_message = models.JSONField(null=True, blank=True)
    output_message = models.JSONField(null=True, blank=True)
    
    # Metadata
    stage_metadata = models.JSONField(null=True, blank=True)
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'swf_agent_workflow_stages'
        ordering = ['workflow', 'created_at']
        indexes = [
            models.Index(fields=['workflow', 'agent_type']),
            models.Index(fields=['agent_name', 'status']),
            models.Index(fields=['received_at']),
        ]
        unique_together = [['workflow', 'agent_name', 'agent_type']]

    def __str__(self):
        return f"Stage {self.agent_name} ({self.agent_type}) - {self.status}"

    def mark_received(self, message=None):
        """Mark the stage as received by the agent."""
        self.received_at = timezone.now()
        self.status = f"{self.agent_type.lower()}_received"
        if message:
            self.input_message = message
        self.save()

    def mark_processing(self):
        """Mark the stage as being processed."""
        self.started_at = timezone.now()
        self.status = f"{self.agent_type.lower()}_processing"
        self.save()

    def mark_completed(self, output_message=None):
        """Mark the stage as completed."""
        self.completed_at = timezone.now()
        self.status = f"{self.agent_type.lower()}_complete"
        if output_message:
            self.output_message = output_message
        
        # Calculate processing time
        if self.started_at:
            self.processing_time_seconds = (self.completed_at - self.started_at).total_seconds()
        
        self.save()

    def mark_failed(self, reason):
        """Mark the stage as failed."""
        self.failed_at = timezone.now()
        self.status = WorkflowStatus.FAILED
        self.failure_reason = reason
        self.save()


class WorkflowMessage(models.Model):
    """
    Tracks all messages exchanged in the workflow system.

    Provides workflow-specific message tracking with agent identification and message type categorization.
    """
    message_id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
    # Relationships
    workflow = models.ForeignKey(STFWorkflow, on_delete=models.CASCADE, related_name='messages', null=True, blank=True)
    stage = models.ForeignKey(AgentWorkflowStage, on_delete=models.CASCADE, related_name='messages', null=True, blank=True)
    
    # Message identification
    message_type = models.CharField(max_length=50)  # e.g., 'stf_gen', 'data_ready', 'proc_complete'
    request_id = models.IntegerField(null=True, blank=True)
    
    # Agent information
    sender_agent = models.CharField(max_length=100, null=True, blank=True)
    sender_type = models.CharField(max_length=20, choices=AgentType.choices, null=True, blank=True)
    recipient_agent = models.CharField(max_length=100, null=True, blank=True)
    recipient_type = models.CharField(max_length=20, choices=AgentType.choices, null=True, blank=True)

    # Namespace for multi-user disambiguation
    namespace = models.CharField(max_length=100, null=True, blank=True, db_index=True,
                                 help_text="Testbed namespace for multi-user message filtering")
    
    # Message content
    message_content = models.JSONField()
    
    # Extensible metadata for monitoring and debugging
    message_metadata = models.JSONField(null=True, blank=True, default=dict, help_text="Extensible metadata for monitoring, debugging, and system tracking")
    
    # Delivery tracking
    sent_at = models.DateTimeField(auto_now_add=True)
    delivered_at = models.DateTimeField(null=True, blank=True)
    acknowledged_at = models.DateTimeField(null=True, blank=True)
    
    # Status
    is_successful = models.BooleanField(null=True, default=None)
    error_message = models.TextField(null=True, blank=True)
    
    # ActiveMQ specific fields
    queue_name = models.CharField(max_length=100, null=True, blank=True)
    correlation_id = models.CharField(max_length=100, null=True, blank=True)

    class Meta:
        db_table = 'swf_workflow_messages'
        ordering = ['-sent_at']
        indexes = [
            models.Index(fields=['workflow', 'message_type']),
            models.Index(fields=['sender_agent', 'sent_at']),
            models.Index(fields=['message_type', 'sent_at']),
        ]

    def __str__(self):
        return f"Message {self.message_type} from {self.sender_agent} at {self.sent_at}"

    def mark_delivered(self):
        """Mark the message as delivered."""
        self.delivered_at = timezone.now()
        self.is_successful = True
        self.save()

    def mark_failed(self, error):
        """Mark the message as failed."""
        self.is_successful = False
        self.error_message = error
        self.save()


class WorkflowDefinition(models.Model):
    """
    Defines reusable workflow templates with parameters and execution logic.
    """
    workflow_name = models.CharField(max_length=200, help_text="Unique workflow name")
    version = models.CharField(max_length=50, help_text="Version string")
    workflow_type = models.CharField(max_length=100, help_text="Flexible workflow type classification")
    definition = models.TextField(help_text="Python workflow code content")
    parameter_values = models.JSONField(default=dict, help_text="Default parameter values and schema")
    created_by = models.CharField(max_length=100, help_text="Username who created this workflow")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'swf_workflow_definitions'
        unique_together = [['workflow_name', 'version']]

    def __str__(self):
        return f"{self.workflow_name} v{self.version}"


class WorkflowExecution(models.Model):
    """
    Tracks individual workflow execution instances.
    """
    execution_id = models.CharField(primary_key=True, max_length=100, help_text="Human-readable execution ID")
    workflow_definition = models.ForeignKey(WorkflowDefinition, on_delete=models.CASCADE, related_name='executions')
    parameter_values = models.JSONField(help_text="Actual parameter values used for this execution")
    performance_metrics = models.JSONField(null=True, blank=True, help_text="Performance metrics and results")
    status = models.CharField(max_length=50, default='pending', help_text="Flexible execution status")
    start_time = models.DateTimeField(help_text="Execution start timestamp")
    end_time = models.DateTimeField(null=True, blank=True, help_text="Execution completion timestamp")
    executed_by = models.CharField(max_length=100, help_text="Username who executed this workflow")

    class Meta:
        db_table = 'swf_workflow_executions'
        ordering = ['-start_time']

    def __str__(self):
        return f"Execution {self.execution_id} ({self.status})"