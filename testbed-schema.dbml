Project "None" {
  database_type: 'PostgreSQL'
  Note: '''None
  Last Updated At 08-26-2025 08:27PM UTC'''
}

enum admin.positive_small_integer_logentry_action_flag {
  "1" [note: '''Addition''']
  "2" [note: '''Change''']
  "3" [note: '''Deletion''']
}

enum monitor_app.char_agentworkflowstage_agent_type {
  "daqsim" [note: '''DAQ Simulator''']
  "data" [note: '''Data Agent''']
  "processing" [note: '''Processing Agent''']
  "fastmon" [note: '''Fast Monitoring Agent''']
  "monitor" [note: '''Monitor System''']
}

enum monitor_app.char_agentworkflowstage_status {
  "generated" [note: '''Generated by DAQ''']
  "daqsim_received" [note: '''Received by DAQSIM Agent''']
  "daqsim_processing" [note: '''DAQSIM Agent Processing''']
  "daqsim_complete" [note: '''DAQSIM Agent Complete''']
  "data_received" [note: '''Received by Data Agent''']
  "data_processing" [note: '''Data Agent Processing''']
  "data_complete" [note: '''Data Agent Complete''']
  "processing_received" [note: '''Received by Processing Agent''']
  "processing_processing" [note: '''Processing Agent Processing''']
  "processing_complete" [note: '''Processing Agent Complete''']
  "fastmon_received" [note: '''Received by FastMon Agent''']
  "fastmon_processing" [note: '''FastMon Agent Processing''']
  "fastmon_complete" [note: '''FastMon Agent Complete''']
  "workflow_complete" [note: '''Workflow Complete''']
  "failed" [note: '''Failed''']
}

enum monitor_app.char_fastmonfile_status {
  "registered" [note: '''Registered''']
  "processing" [note: '''Processing''']
  "processed" [note: '''Processed''']
  "failed" [note: '''Failed''']
  "done" [note: '''Done''']
}

enum monitor_app.char_stffile_status {
  "registered" [note: '''Registered''']
  "processing" [note: '''Processing''']
  "processed" [note: '''Processed''']
  "failed" [note: '''Failed''']
  "done" [note: '''Done''']
}

enum monitor_app.char_stfworkflow_current_agent {
  "daqsim" [note: '''DAQ Simulator''']
  "data" [note: '''Data Agent''']
  "processing" [note: '''Processing Agent''']
  "fastmon" [note: '''Fast Monitoring Agent''']
  "monitor" [note: '''Monitor System''']
}

enum monitor_app.char_stfworkflow_current_status {
  "generated" [note: '''Generated by DAQ''']
  "daqsim_received" [note: '''Received by DAQSIM Agent''']
  "daqsim_processing" [note: '''DAQSIM Agent Processing''']
  "daqsim_complete" [note: '''DAQSIM Agent Complete''']
  "data_received" [note: '''Received by Data Agent''']
  "data_processing" [note: '''Data Agent Processing''']
  "data_complete" [note: '''Data Agent Complete''']
  "processing_received" [note: '''Received by Processing Agent''']
  "processing_processing" [note: '''Processing Agent Processing''']
  "processing_complete" [note: '''Processing Agent Complete''']
  "fastmon_received" [note: '''Received by FastMon Agent''']
  "fastmon_processing" [note: '''FastMon Agent Processing''']
  "fastmon_complete" [note: '''FastMon Agent Complete''']
  "workflow_complete" [note: '''Workflow Complete''']
  "failed" [note: '''Failed''']
}

enum monitor_app.char_stfworkflow_daq_state {
  "no_beam" [note: '''No Beam''']
  "beam" [note: '''Beam''']
  "run" [note: '''Run''']
  "calib" [note: '''Calibration''']
  "test" [note: '''Test''']
}

enum monitor_app.char_stfworkflow_daq_substate {
  "not_ready" [note: '''Not Ready''']
  "ready" [note: '''Ready''']
  "physics" [note: '''Physics''']
  "standby" [note: '''Standby''']
  "lumi" [note: '''Luminosity''']
  "eic" [note: '''EIC''']
  "epic" [note: '''ePIC''']
  "daq" [note: '''DAQ''']
  "calib" [note: '''Calibration''']
}

enum monitor_app.char_subscriber_delivery_type {
  "activemq" [note: '''ActiveMQ Direct''']
  "sse" [note: '''Server-Sent Events''']
}

enum monitor_app.char_systemagent_agent_type {
  "daqsim" [note: '''DAQ Simulator''']
  "data" [note: '''Data Agent''']
  "processing" [note: '''Processing Agent''']
  "fastmon" [note: '''Fast Monitoring Agent''']
  "monitor" [note: '''Monitor System''']
  "test" [note: '''Test Agent''']
  "other" [note: '''Other''']
}

enum monitor_app.char_systemagent_status {
  "UNKNOWN" [note: '''Unknown''']
  "OK" [note: '''OK''']
  "WARNING" [note: '''Warning''']
  "ERROR" [note: '''Error''']
}

enum monitor_app.char_workflowmessage_recipient_type {
  "daqsim" [note: '''DAQ Simulator''']
  "data" [note: '''Data Agent''']
  "processing" [note: '''Processing Agent''']
  "fastmon" [note: '''Fast Monitoring Agent''']
  "monitor" [note: '''Monitor System''']
}

enum monitor_app.char_workflowmessage_sender_type {
  "daqsim" [note: '''DAQ Simulator''']
  "data" [note: '''Data Agent''']
  "processing" [note: '''Processing Agent''']
  "fastmon" [note: '''Fast Monitoring Agent''']
  "monitor" [note: '''Monitor System''']
}

enum monitor_app.integer_applog_level {
  "50" [note: '''CRITICAL''']
  "40" [note: '''ERROR''']
  "30" [note: '''WARNING''']
  "20" [note: '''INFO''']
  "10" [note: '''DEBUG''']
  "0" [note: '''NOTSET''']
}

Table admin.LogEntry {
  Note: '''
LogEntry(id, action_time, user, content_type, object_id, object_repr, action_flag, change_message)

*DB table: django_admin_log*'''

  id auto [pk, unique, not null]
  action_time date_time [default:`django.utils.timezone.now()`, not null]
  user_id foreign_key [not null]
  content_type_id foreign_key [null]
  object_id text [null]
  object_repr char [not null]
  action_flag admin.positive_small_integer_logentry_action_flag [not null]
  change_message text [not null]

  indexes {
    (content_type_id) [name: 'django_admin_log_content_type_id_c4bce8eb', type: btree]
    (id) [pk, unique, name: 'django_admin_log_pkey', type: btree]
    (user_id) [name: 'django_admin_log_user_id_c564eba6', type: btree]
  }
}
ref: admin.LogEntry.user_id > auth.User.id
ref: admin.LogEntry.content_type_id > contenttypes.ContentType.id


Table auth.Group {
  Note: '''
Groups are a generic way of categorizing users to apply permissions, or
some other label, to those users. A user can belong to any number of
groups.

A user in a group automatically has all the permissions granted to that
group. For example, if the group 'Site editors' has the permission
can_edit_home_page, any user in that group will have that permission.

Beyond permissions, groups are a convenient way to categorize users to
apply some label, or extended functionality, to them. For example, you
could create a group 'Special users', and you could write code that would
do special things to those users -- such as giving them access to a
members-only portion of your site, or sending them members-only email
messages.


*DB table: auth_group*'''

  id auto [pk, unique, not null]
  name char [unique, not null]

  indexes {
    (name) [unique, name: 'auth_group_name_key', type: btree]
    (id) [pk, unique, name: 'auth_group_pkey', type: btree]
  }
}


Table auth.Permission {
  Note: '''
The permissions system provides a way to assign permissions to specific
users and groups of users.

The permission system is used by the Django admin site, but may also be
useful in your own code. The Django admin site uses permissions as follows:

- The "add" permission limits the user's ability to view the "add" form
and add an object.
- The "change" permission limits a user's ability to view the change
list, view the "change" form and change an object.
- The "delete" permission limits the ability to delete an object.
- The "view" permission limits the ability to view an object.

Permissions are set globally per type of object, not per specific object
instance. It is possible to say "Mary may change news stories," but it's
not currently possible to say "Mary may change news stories, but only the
ones she created herself" or "Mary may only change news stories that have a
certain status or publication date."

The permissions listed above are automatically created for each model.


*DB table: auth_permission*'''

  id auto [pk, unique, not null]
  name char [not null]
  content_type_id foreign_key [not null]
  codename char [not null]

  indexes {
    (content_type_id) [name: 'auth_permission_content_type_id_2f476e4b', type: btree]
    (content_type_id,codename) [unique, name: 'auth_permission_content_type_id_codename_01ab375a_uniq', type: btree]
    (id) [pk, unique, name: 'auth_permission_pkey', type: btree]
  }
}
ref: auth.Permission.content_type_id > contenttypes.ContentType.id


Table auth.User {
  Note: '''
Users within the Django authentication system are represented by this
model.

Username and password are required. Other fields are optional.


*DB table: auth_user*'''

  id auto [pk, unique, not null]
  password char [not null]
  last_login date_time [null]
  is_superuser boolean [note: '''Designates that this user has all permissions without explicitly assigning them.''', default:`False`, not null]
  username char [note: '''Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.''', unique, not null]
  first_name char [not null]
  last_name char [not null]
  email email [not null]
  is_staff boolean [note: '''Designates whether the user can log into this admin site.''', default:`False`, not null]
  is_active boolean [note: '''Designates whether this user should be treated as active. Unselect this instead of deleting accounts.''', default:`True`, not null]
  date_joined date_time [default:`django.utils.timezone.now()`, not null]

  indexes {
    (id) [pk, unique, name: 'auth_user_pkey', type: btree]
    (username) [unique, name: 'auth_user_username_key', type: btree]
  }
}


Table auth.group_permissions {
  Note: '''
This is a Many-To-Many linking table autogenerated by Django.

*DB table: auth_group_permissions*'''

  id auto [pk, not null]
  permission_id auto
  group_id auto

  indexes {
    (group_id) [name: 'auth_group_permissions_group_id_b120cbf9', type: btree]
    (group_id,permission_id) [unique, name: 'auth_group_permissions_group_id_permission_id_0cd325b0_uniq', type: btree]
    (permission_id) [name: 'auth_group_permissions_permission_id_84c5c92e', type: btree]
    (id) [pk, unique, name: 'auth_group_permissions_pkey', type: btree]
  }
}
ref: auth.Group.id > auth.group_permissions.group_id
ref: auth.Permission.id > auth.group_permissions.permission_id


Table auth.user_groups {
  Note: '''
This is a Many-To-Many linking table autogenerated by Django.

*DB table: auth_user_groups*'''

  id auto [pk, not null]
  group_id auto
  user_id auto

  indexes {
    (group_id) [name: 'auth_user_groups_group_id_97559544', type: btree]
    (id) [pk, unique, name: 'auth_user_groups_pkey', type: btree]
    (user_id) [name: 'auth_user_groups_user_id_6a12ed8b', type: btree]
    (user_id,group_id) [unique, name: 'auth_user_groups_user_id_group_id_94350c0c_uniq', type: btree]
  }
}
ref: auth.User.id > auth.user_groups.user_id
ref: auth.Group.id > auth.user_groups.group_id


Table auth.user_user_permissions {
  Note: '''
This is a Many-To-Many linking table autogenerated by Django.

*DB table: auth_user_user_permissions*'''

  id auto [pk, not null]
  permission_id auto
  user_id auto

  indexes {
    (permission_id) [name: 'auth_user_user_permissions_permission_id_1fbb5f2c', type: btree]
    (id) [pk, unique, name: 'auth_user_user_permissions_pkey', type: btree]
    (user_id) [name: 'auth_user_user_permissions_user_id_a95ead1b', type: btree]
    (user_id,permission_id) [unique, name: 'auth_user_user_permissions_user_id_permission_id_14a6b632_uniq', type: btree]
  }
}
ref: auth.User.id > auth.user_user_permissions.user_id
ref: auth.Permission.id > auth.user_user_permissions.permission_id


Table authtoken.Token {
  Note: '''
The default authorization token model.


*DB table: authtoken_token*'''

  key char [pk, unique, not null]
  user_id one_to_one [unique, not null]
  created date_time [not null]

  indexes {
    (key) [pk, unique, name: 'authtoken_token_pkey', type: btree]
    (user_id) [unique, name: 'authtoken_token_user_id_key', type: btree]
  }
}
ref: authtoken.Token.user_id - auth.User.id


Table authtoken.TokenProxy {
  Note: '''
Proxy mapping pk to user pk for use in admin.


*DB table: authtoken_token*'''

  key char [pk, unique, not null]
  user_id one_to_one [unique, not null]
  created date_time [not null]

  indexes {
    (key) [pk, unique, name: 'authtoken_token_pkey', type: btree]
    (user_id) [unique, name: 'authtoken_token_user_id_key', type: btree]
  }
}
ref: authtoken.TokenProxy.user_id - auth.User.id


Table contenttypes.ContentType {
  Note: '''
ContentType(id, app_label, model)

*DB table: django_content_type*'''

  id auto [pk, unique, not null]
  app_label char [not null]
  model char [not null]

  indexes {
    (app_label,model) [unique, name: 'django_content_type_app_label_model_76bd3d3b_uniq', type: btree]
    (id) [pk, unique, name: 'django_content_type_pkey', type: btree]
  }
}


Table monitor_app.AgentWorkflowStage {
  Note: '''
Tracks individual agent processing stages within an STF workflow.

This model records when each agent receives, processes, and completes work on an STF,
providing detailed timing and status information for performance monitoring.


*DB table: swf_agent_workflow_stages*'''

  stage_id uuid [pk, unique, default:`uuid.uuid4()`, not null]
  workflow_id foreign_key [not null]
  agent_name char [not null]
  agent_type monitor_app.char_agentworkflowstage_agent_type [not null]
  status monitor_app.char_agentworkflowstage_status [default:`"generated"`, not null]
  received_at date_time [null]
  started_at date_time [null]
  completed_at date_time [null]
  failed_at date_time [null]
  processing_time_seconds float [null]
  failure_reason text [null]
  input_message json [null]
  output_message json [null]
  stage_metadata json [null]
  created_at date_time [not null]
  updated_at date_time [not null]

  indexes {
    (agent_name,status) [name: 'swf_agent_w_agent_n_998699_idx', type: btree]
    (received_at) [name: 'swf_agent_w_receive_6c232f_idx', type: btree]
    (workflow_id,agent_type) [name: 'swf_agent_w_workflo_2375d6_idx', type: btree]
    (workflow_id,agent_name,agent_type) [unique, name: 'swf_agent_workflow_stage_workflow_id_agent_name_a_fc327599_uniq', type: btree]
    (stage_id) [pk, unique, name: 'swf_agent_workflow_stages_pkey', type: btree]
    (workflow_id) [name: 'swf_agent_workflow_stages_workflow_id_060467ec', type: btree]
  }
}
ref: monitor_app.AgentWorkflowStage.workflow_id > monitor_app.STFWorkflow.workflow_id


Table monitor_app.AppLog {
  Note: '''
AppLog(id, app_name, instance_name, timestamp, level, levelname, message, module, funcname, lineno, process, thread, extra_data)

*DB table: swf_applog*'''

  id big_auto [pk, unique, not null]
  app_name char [not null]
  instance_name char [not null]
  timestamp date_time [not null]
  level monitor_app.integer_applog_level [default:`0`, not null]
  levelname char [not null]
  message text [not null]
  module char [not null]
  funcname char [not null]
  lineno integer [not null]
  process integer [not null]
  thread big_integer [not null]
  extra_data json [null]

  indexes {
    (app_name) [name: 'swf_applog_app_name_66f0dc0f', type: btree]
    (instance_name) [name: 'swf_applog_instance_name_9c1c173c', type: btree]
    (level) [name: 'swf_applog_level_45df2d72', type: btree]
    (id) [pk, unique, name: 'swf_applog_pkey', type: btree]
    (timestamp,app_name,instance_name) [name: 'swf_applog_timesta_ad9cbc_idx', type: btree]
    (timestamp) [name: 'swf_applog_timestamp_fb0b69c3', type: btree]
  }
}


Table monitor_app.FastMonFile {
  Note: '''
Represents a Time Frame (TF) file for fast monitoring.
TF files are subsamples of Super Time Frame (STF) files, processed for rapid monitoring.

Attributes:
tf_file_id: UUID primary key for unique TF file identification
stf_file: Foreign key to the parent STF file this TF is derived from
tf_filename: Unique filename for the TF file
file_size_bytes: Size of the TF file in bytes
checksum: File integrity checksum
status: Current processing status (FileStatus enum)
metadata: JSON field for flexible storage of TF-specific metadata
created_at: Timestamp when TF record was created
updated_at: Timestamp when TF record was last modified


*DB table: swf_fastmon_files*'''

  tf_file_id uuid [pk, unique, default:`uuid.uuid4()`, not null]
  stf_file_id foreign_key [not null]
  tf_filename char [unique, not null]
  file_size_bytes big_integer [null]
  checksum char [null]
  status monitor_app.char_fastmonfile_status [default:`"registered"`, not null]
  metadata json [null]
  created_at date_time [not null]
  updated_at date_time [not null]

  indexes {
    (tf_file_id) [pk, unique, name: 'swf_fastmon_files_pkey', type: btree]
    (stf_file_id) [name: 'swf_fastmon_files_stf_file_id_5994a143', type: btree]
    (tf_filename) [unique, name: 'swf_fastmon_files_tf_filename_key', type: btree]
  }
}
ref: monitor_app.FastMonFile.stf_file_id > monitor_app.StfFile.file_id


Table monitor_app.MessageQueueDispatch {
  Note: '''
Records message queue dispatch operations for STF file events.

Tracks when and how STF file notifications are sent to message queues, including success/failure status and error 
details for monitoring.

Attributes:
dispatch_id: UUID primary key for unique dispatch identification
stf_file: Foreign key to the associated STF file
dispatch_time: Timestamp when the dispatch occurred (auto_now_add)
message_content: JSON content of the dispatched message
is_successful: Whether the dispatch succeeded
error_message: Error details if dispatch failed


*DB table: swf_message_queue_dispatches*'''

  dispatch_id uuid [pk, unique, default:`uuid.uuid4()`, not null]
  stf_file_id foreign_key [not null]
  dispatch_time date_time [not null]
  message_content json [null]
  is_successful boolean [default:`None`, null]
  error_message text [null]
  workflow_id uuid [null]
  message_type char [null]
  sender_agent char [null]
  recipient_agent char [null]

  indexes {
    (dispatch_id) [pk, unique, name: 'swf_message_queue_dispatches_pkey', type: btree]
    (stf_file_id) [name: 'swf_message_queue_dispatches_stf_file_id_034d1fe8', type: btree]
    (workflow_id) [name: 'swf_message_queue_dispatches_workflow_id_70cbace2', type: btree]
  }
}
ref: monitor_app.MessageQueueDispatch.stf_file_id > monitor_app.StfFile.file_id


Table monitor_app.PandaQueue {
  Note: '''
Represents a PanDA compute queue configuration.
Stores the queue name and full configuration as JSON.


*DB table: swf_panda_queues*'''

  queue_name char [pk, unique, not null]
  site char [not null]
  status char [default:`"active"`, not null]
  queue_type char [not null]
  config_data json [not null]
  created_at date_time [not null]
  updated_at date_time [not null]

  indexes {
    (queue_name) [pk, unique, name: 'swf_panda_queues_pkey', type: btree]
  }
}


Table monitor_app.PersistentState {
  Note: '''
Persistent state store with stable schema - just stores JSON.
Never modify this schema - it must remain stable across all deployments.

Single record stores all persistent state as JSON blob.
Use get_state() and update_state() methods to access nested data.


*DB table: swf_persistent_state*'''

  id auto [pk, unique, not null]
  state_data json [default:`builtins.dict()`, not null]
  updated_at date_time [not null]

  indexes {
    (id) [pk, unique, name: 'swf_persistent_state_pkey', type: btree]
  }
}


Table monitor_app.RucioEndpoint {
  Note: '''
Represents a Rucio DDM (Distributed Data Management) endpoint configuration.
Stores the endpoint name and full configuration as JSON.


*DB table: swf_rucio_endpoints*'''

  endpoint_name char [pk, unique, not null]
  site char [not null]
  endpoint_type char [not null]
  is_tape boolean [default:`False`, not null]
  is_active boolean [default:`True`, not null]
  config_data json [not null]
  created_at date_time [not null]
  updated_at date_time [not null]

  indexes {
    (endpoint_name) [pk, unique, name: 'swf_rucio_endpoints_pkey', type: btree]
  }
}


Table monitor_app.Run {
  Note: '''
Represents a data-taking run in the ePIC detector system.

Attributes:
run_id: Auto-incrementing primary key
run_number: Unique identifier for the run, defined by DAQ 
start_time: When the run began
end_time: When the run ended (null if still active)
run_conditions: JSON field storing experimental conditions


*DB table: swf_runs*'''

  run_id auto [pk, unique, not null]
  run_number integer [unique, not null]
  start_time date_time [not null]
  end_time date_time [null]
  run_conditions json [null]

  indexes {
    (run_id) [pk, unique, name: 'swf_runs_pkey', type: btree]
    (run_number) [unique, name: 'swf_runs_run_number_key', type: btree]
  }
}


Table monitor_app.STFWorkflow {
  Note: '''
Tracks the complete workflow lifecycle of a Super Time Frame from generation to completion.

This model extends the existing StfFile model concept to include workflow-specific fields
and tracks the STF as it moves through different agents in the pipeline.


*DB table: swf_stf_workflows*'''

  workflow_id uuid [pk, unique, default:`uuid.uuid4()`, not null]
  filename char [unique, not null]
  file_id uuid [null]
  daq_state monitor_app.char_stfworkflow_daq_state [not null]
  daq_substate monitor_app.char_stfworkflow_daq_substate [not null]
  generated_time date_time [not null]
  stf_start_time date_time [not null]
  stf_end_time date_time [not null]
  current_status monitor_app.char_stfworkflow_current_status [default:`"generated"`, not null]
  current_agent monitor_app.char_stfworkflow_current_agent [default:`"daqsim"`, not null]
  completed_at date_time [null]
  failed_at date_time [null]
  failure_reason text [null]
  stf_metadata json [null]
  created_at date_time [not null]
  updated_at date_time [not null]

  indexes {
    (current_status,generated_time) [name: 'swf_stf_wor_current_2362bd_idx', type: btree]
    (current_agent) [name: 'swf_stf_wor_current_b6bc73_idx', type: btree]
    (daq_state,daq_substate) [name: 'swf_stf_wor_daq_sta_d7effc_idx', type: btree]
    (filename) [unique, name: 'swf_stf_workflows_filename_key', type: btree]
    (workflow_id) [pk, unique, name: 'swf_stf_workflows_pkey', type: btree]
  }
}


Table monitor_app.StfFile {
  Note: '''
Represents a Super Time Frame (STF) file in the data acquisition system.
Each file is tracked with metadata, processing status, and location
information for monitoring and message queue dispatch.

Attributes:
file_id: UUID primary key for unique file identification
run: Foreign key to the associated Run
machine_state: Detector state during data collection (e.g., "physics", "cosmics")
file_url: URL location of the STF file, intended for remote access
file_size_bytes: Size of the file in bytes
checksum: File integrity checksum
created_at: Timestamp when file record was created
status: Current processing status (FileStatus enum)
metadata: JSON field for additional file metadata


*DB table: swf_stf_files*'''

  file_id uuid [pk, unique, default:`uuid.uuid4()`, not null]
  run_id foreign_key [not null]
  machine_state char [default:`"physics"`, not null]
  stf_filename char [unique, not null]
  file_size_bytes big_integer [null]
  checksum char [null]
  created_at date_time [not null]
  status monitor_app.char_stffile_status [default:`"registered"`, not null]
  metadata json [null]
  workflow_id uuid [null]
  daq_state char [null]
  daq_substate char [null]
  workflow_status char [null]

  indexes {
    (file_id) [pk, unique, name: 'swf_stf_files_pkey', type: btree]
    (run_id) [name: 'swf_stf_files_run_id_9a2165d5', type: btree]
    (stf_filename) [unique, name: 'swf_stf_files_stf_filename_key', type: btree]
    (workflow_id) [name: 'swf_stf_files_workflow_id_055cc696', type: btree]
  }
}
ref: monitor_app.StfFile.run_id > monitor_app.Run.run_id


Table monitor_app.Subscriber {
  Note: '''
Represents a message queue subscriber in the monitoring system. 
Subscribers receive notifications about STF files via ActiveMQ directly or SSE.

Attributes:
subscriber_id: Auto-incrementing primary key
subscriber_name: Unique name identifying the subscriber
fraction: Fraction of messages to receive  
description: Human-readable description of the subscriber
is_active: Whether the subscriber is currently active
created_at: Timestamp when record was created
updated_at: Timestamp when record was last updated
delivery_type: How messages are delivered (activemq or sse)
client_ip: IP address for SSE subscribers
client_location: Geographic location for SSE subscribers
connected_at: When SSE subscriber connected
disconnected_at: When SSE subscriber disconnected
last_activity: Last activity timestamp for SSE subscribers
message_filters: JSON filters for SSE message selection
messages_received: Count of messages received
messages_sent: Count of messages sent (SSE)
messages_dropped: Count of messages dropped due to queue overflow (SSE)


*DB table: swf_subscribers*'''

  subscriber_id auto [pk, unique, not null]
  subscriber_name char [unique, not null]
  fraction float [null]
  description text [null]
  is_active boolean [default:`True`, not null]
  created_at date_time [not null]
  updated_at date_time [not null]
  delivery_type monitor_app.char_subscriber_delivery_type [default:`"activemq"`, not null]
  client_ip generic_ip_address [null]
  client_location char [default:`""`, not null]
  connected_at date_time [null]
  disconnected_at date_time [null]
  last_activity date_time [null]
  message_filters json [default:`builtins.dict()`, not null]
  messages_received integer [default:`0`, not null]
  messages_sent integer [default:`0`, not null]
  messages_dropped integer [default:`0`, not null]

  indexes {
    (delivery_type,is_active) [name: 'swf_subscri_deliver_1836c2_idx', type: btree]
    (subscriber_id) [pk, unique, name: 'swf_subscribers_pkey', type: btree]
    (subscriber_name) [unique, name: 'swf_subscribers_subscriber_name_key', type: btree]
  }
}


Table monitor_app.SystemAgent {
  Note: '''
SystemAgent(id, instance_name, agent_type, description, status, last_heartbeat, agent_url, workflow_enabled, current_stf_count, total_stf_processed, last_stf_processed, created_at, updated_at)

*DB table: swf_systemagent*'''

  id big_auto [pk, unique, not null]
  instance_name char [unique, not null]
  agent_type monitor_app.char_systemagent_agent_type [not null]
  description text [not null]
  status monitor_app.char_systemagent_status [default:`"UNKNOWN"`, not null]
  last_heartbeat date_time [null]
  agent_url url [null]
  workflow_enabled boolean [default:`True`, not null]
  current_stf_count integer [default:`0`, not null]
  total_stf_processed integer [default:`0`, not null]
  last_stf_processed date_time [null]
  created_at date_time [not null]
  updated_at date_time [not null]

  indexes {
    (instance_name) [unique, name: 'swf_systemagent_instance_name_key', type: btree]
    (id) [pk, unique, name: 'swf_systemagent_pkey', type: btree]
  }
}


Table monitor_app.WorkflowMessage {
  Note: '''
Tracks all messages exchanged in the workflow system.

This extends the existing MessageQueueDispatch concept to include workflow-specific
message tracking with agent identification and message type categorization.


*DB table: swf_workflow_messages*'''

  message_id uuid [pk, unique, default:`uuid.uuid4()`, not null]
  workflow_id foreign_key [null]
  stage_id foreign_key [null]
  message_type char [not null]
  request_id integer [null]
  sender_agent char [null]
  sender_type monitor_app.char_workflowmessage_sender_type [null]
  recipient_agent char [null]
  recipient_type monitor_app.char_workflowmessage_recipient_type [null]
  message_content json [not null]
  sent_at date_time [not null]
  delivered_at date_time [null]
  acknowledged_at date_time [null]
  is_successful boolean [default:`None`, null]
  error_message text [null]
  queue_name char [null]
  correlation_id char [null]

  indexes {
    (message_type,sent_at) [name: 'swf_workflo_message_cb52f7_idx', type: btree]
    (sender_agent,sent_at) [name: 'swf_workflo_sender__34fb10_idx', type: btree]
    (workflow_id,message_type) [name: 'swf_workflo_workflo_0fe275_idx', type: btree]
    (message_id) [pk, unique, name: 'swf_workflow_messages_pkey', type: btree]
    (stage_id) [name: 'swf_workflow_messages_stage_id_221b9ea1', type: btree]
    (workflow_id) [name: 'swf_workflow_messages_workflow_id_0515ebc8', type: btree]
  }
}
ref: monitor_app.WorkflowMessage.workflow_id > monitor_app.STFWorkflow.workflow_id
ref: monitor_app.WorkflowMessage.stage_id > monitor_app.AgentWorkflowStage.stage_id


Table sessions.Session {
  Note: '''
Django provides full support for anonymous sessions. The session
framework lets you store and retrieve arbitrary data on a
per-site-visitor basis. It stores data on the server side and
abstracts the sending and receiving of cookies. Cookies contain a
session ID -- not the data itself.

The Django sessions framework is entirely cookie-based. It does
not fall back to putting session IDs in URLs. This is an intentional
design decision. Not only does that behavior make URLs ugly, it makes
your site vulnerable to session-ID theft via the "Referer" header.

For complete documentation on using Sessions in your code, consult
the sessions documentation that is shipped with Django (also available
on the Django web site).


*DB table: django_session*'''

  session_key char [pk, unique, not null]
  session_data text [not null]
  expire_date date_time [not null]

  indexes {
    (expire_date) [name: 'django_session_expire_date_a5c62663', type: btree]
    (session_key) [pk, unique, name: 'django_session_pkey', type: btree]
  }
}


